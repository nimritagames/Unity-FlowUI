# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“š LEARNING: Release Workflow
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# PURPOSE: This workflow automates releases when you merge to 'main' branch.
#          It creates GitHub releases, generates changelogs, and publishes
#          your package automatically!
#
# WHEN IT RUNS:
#   - When you push to main branch (e.g., merging development â†’ main)
#   - When you create a version tag (e.g., v1.0.0, v1.1.0)
#
# WHAT IT DOES:
#   1. Detects version from package.json
#   2. Creates GitHub release with auto-generated changelog
#   3. Uploads package as release artifact
#   4. Tags the commit if not already tagged
#
# WHY THIS MATTERS:
#   - Automates the entire release process (saves hours!)
#   - Professional release notes from commit messages
#   - Users can install directly from releases
#   - Maintains version history automatically
#
# YOUR WORKFLOW:
#   development (daily work) â†’ main (trigger this!) â†’ GitHub Release
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Release Package

# ğŸ“š LEARNING: This workflow has TWO triggers
on:
  # ğŸ“š LEARNING: Trigger on pushes to main OR version tags
  push:
    # Trigger 1: When you push to main (e.g., merge development)
    branches:
      - main
    # Trigger 2: When you create a version tag manually (e.g., v1.1.0)
    tags:
      - 'v*'  # Matches v1.0.0, v2.1.3, etc.
    # ğŸ“š LEARNING: Only run if package.json version changed
    # This prevents releases on every main push (only applies to branch pushes)
    paths:
      - 'Packages/com.nimrita.flowui/package.json'

# ğŸ“š LEARNING: Environment variables for this workflow
env:
  PACKAGE_PATH: Packages/com.nimrita.flowui

# ğŸ“š LEARNING: We need write permissions to create releases
permissions:
  contents: write  # Allows creating releases and tags

jobs:

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: Create GitHub Release
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  create-release:
    name: ğŸš€ Create Release
    runs-on: ubuntu-latest

    # ğŸ“š LEARNING: Only run if tests passed on development branch
    # This ensures we don't release broken code
    # Note: You can add a "needs: test" dependency once tests run on main too

    steps:

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 1: Get the code
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          # ğŸ“š LEARNING: Fetch all history for changelog generation
          fetch-depth: 0

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 2: Extract version from package.json
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      # ğŸ“š LEARNING: We read the version from package.json
      # This is the single source of truth for versioning
      - name: ğŸ“‹ Get Package Version
        id: package-version
        run: |
          # Read version from package.json using jq (JSON processor)
          VERSION=$(jq -r '.version' ${{ env.PACKAGE_PATH }}/package.json)

          # ğŸ“š LEARNING: Set output variable for use in later steps
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

          echo "ğŸ“¦ Package Version: $VERSION"
          echo "ğŸ·ï¸  Tag will be: v$VERSION"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 3: Check if this version already exists
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      # ğŸ“š LEARNING: Prevent duplicate releases
      - name: ğŸ” Check if Release Exists
        id: check-release
        run: |
          TAG="${{ steps.package-version.outputs.tag }}"

          # Check if tag exists remotely
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âš ï¸  Release $TAG already exists!"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âœ… Release $TAG is new!"
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 4: Generate Changelog
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      # ğŸ“š LEARNING: Auto-generate changelog from commit messages
      # This step only runs if release doesn't exist
      - name: ğŸ“ Generate Changelog
        id: changelog
        if: steps.check-release.outputs.exists == 'false'
        run: |
          TAG="${{ steps.package-version.outputs.tag }}"

          # ğŸ“š LEARNING: Find the previous release tag
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # ğŸ“š LEARNING: First release - get all commits
            echo "## ğŸ‰ Initial Release" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "### Changes" >> CHANGELOG.md
            git log --pretty=format:"- %s" >> CHANGELOG.md
          else
            # ğŸ“š LEARNING: Generate changelog since last release
            echo "## Changes since $PREV_TAG" > CHANGELOG.md
            echo "" >> CHANGELOG.md

            # Group commits by type (feat, fix, docs, etc.)
            echo "### âœ¨ Features" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --grep="^feat" >> CHANGELOG.md || echo "- No new features" >> CHANGELOG.md
            echo "" >> CHANGELOG.md

            echo "### ğŸ› Bug Fixes" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --grep="^fix" >> CHANGELOG.md || echo "- No bug fixes" >> CHANGELOG.md
            echo "" >> CHANGELOG.md

            echo "### ğŸ“š Documentation" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --grep="^docs" >> CHANGELOG.md || echo "- No documentation changes" >> CHANGELOG.md
            echo "" >> CHANGELOG.md

            echo "### ğŸ”§ Other Changes" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --invert-grep --grep="^feat" --grep="^fix" --grep="^docs" >> CHANGELOG.md || echo "- No other changes" >> CHANGELOG.md
          fi

          echo "" >> CHANGELOG.md
          echo "---" >> CHANGELOG.md
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREV_TAG...$TAG" >> CHANGELOG.md

          # ğŸ“š LEARNING: Show the changelog
          echo "ğŸ“„ Generated Changelog:"
          cat CHANGELOG.md

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 5: Create Package Archive
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      # ğŸ“š LEARNING: Create a .zip of the package for users to download
      - name: ğŸ“¦ Create Package Archive
        if: steps.check-release.outputs.exists == 'false'
        run: |
          PACKAGE_NAME="com.nimrita.flowui-${{ steps.package-version.outputs.version }}"

          # Create a clean copy of the package
          mkdir -p dist
          cp -r ${{ env.PACKAGE_PATH }} "dist/$PACKAGE_NAME"

          # Create zip archive
          cd dist
          zip -r "../$PACKAGE_NAME.zip" "$PACKAGE_NAME"
          cd ..

          echo "âœ… Created: $PACKAGE_NAME.zip"
          ls -lh "$PACKAGE_NAME.zip"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 6: Create GitHub Release
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      # ğŸ“š LEARNING: This uses GitHub CLI (gh) to create the release
      - name: ğŸ‰ Create GitHub Release
        if: steps.check-release.outputs.exists == 'false'
        env:
          # ğŸ“š LEARNING: GitHub automatically provides this token
          # It has permissions based on the workflow's permissions setting
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.package-version.outputs.tag }}"
          VERSION="${{ steps.package-version.outputs.version }}"
          PACKAGE_NAME="com.nimrita.flowui-$VERSION"

          # ğŸ“š LEARNING: Create the release with the generated changelog
          gh release create "$TAG" \
            --title "Flow UI System v$VERSION" \
            --notes-file CHANGELOG.md \
            "$PACKAGE_NAME.zip#Unity Package ($VERSION)"

          echo "âœ… Created release: $TAG"
          echo "ğŸ“¦ Uploaded: $PACKAGE_NAME.zip"
          echo "ğŸ”— View at: https://github.com/${{ github.repository }}/releases/tag/$TAG"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 7: Update CHANGELOG.md in repository
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      # ğŸ“š LEARNING: Optional - Auto-update CHANGELOG.md file
      # This keeps your changelog file in sync with releases
      - name: ğŸ“ Update Repository Changelog
        if: steps.check-release.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.package-version.outputs.version }}"
          DATE=$(date +%Y-%m-%d)

          # Prepend new changelog to existing CHANGELOG.md
          if [ -f "${{ env.PACKAGE_PATH }}/CHANGELOG.md" ]; then
            # Read existing changelog
            cp "${{ env.PACKAGE_PATH }}/CHANGELOG.md" CHANGELOG_OLD.md

            # Create new changelog with new version at top
            echo "# Changelog" > "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            echo "" >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            echo "## [$VERSION] - $DATE" >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            cat CHANGELOG.md >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            echo "" >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"

            # Append old changelog (skip the "# Changelog" header)
            tail -n +2 CHANGELOG_OLD.md >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"

            echo "âœ… Updated CHANGELOG.md"
          fi

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # STEP 8: Commit Updated Changelog (Optional)
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      # ğŸ“š LEARNING: This commits the updated CHANGELOG.md back to the repo
      # Comment this out if you prefer manual changelog management
      - name: ğŸ’¾ Commit Updated Changelog
        if: steps.check-release.outputs.exists == 'false'
        run: |
          # ğŸ“š LEARNING: Configure git for the GitHub Actions bot
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes to commit
          if git diff --quiet ${{ env.PACKAGE_PATH }}/CHANGELOG.md; then
            echo "No changelog changes to commit"
          else
            git add ${{ env.PACKAGE_PATH }}/CHANGELOG.md
            git commit -m "docs: Update CHANGELOG for v${{ steps.package-version.outputs.version }}"
            git push origin main
            echo "âœ… Committed updated CHANGELOG.md"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: Notify on Success
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  # ğŸ“š LEARNING: This job runs after create-release completes
  notify:
    name: ğŸ“¢ Notify Release
    runs-on: ubuntu-latest
    needs: create-release  # Wait for release to complete
    if: success()  # Only run if release succeeded

    steps:
      - name: ğŸŠ Release Success
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ‰ RELEASE SUCCESSFUL!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ Package: Flow UI System"
          echo "ğŸ·ï¸  Version: ${{ needs.create-release.outputs.version }}"
          echo "ğŸ”— Release: https://github.com/${{ github.repository }}/releases"
          echo ""
          echo "âœ… Users can now install this version!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“š LEARNING SUMMARY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# KEY CONCEPTS YOU JUST LEARNED:
#
# 1. RELEASE AUTOMATION
#    - Triggered by pushes to main or version tags
#    - Single source of truth: package.json version
#    - Prevents duplicate releases automatically
#
# 2. CHANGELOG GENERATION
#    - Auto-generated from commit messages
#    - Groups by commit type (feat, fix, docs)
#    - Compares with previous release tag
#
# 3. GITHUB RELEASES
#    - Created using GitHub CLI (gh)
#    - Includes generated changelog
#    - Attaches package zip for download
#
# 4. VERSION MANAGEMENT
#    - Reads from package.json
#    - Creates matching git tag (v1.0.0)
#    - Updates CHANGELOG.md automatically
#
# 5. JOB DEPENDENCIES
#    - needs: create-release (waits for completion)
#    - if: success() (conditional execution)
#    - Job outputs passed between jobs
#
# 6. GITHUB CLI (gh)
#    - gh release create (creates releases)
#    - Uses GITHUB_TOKEN (auto-provided)
#    - Can attach files to releases
#
# 7. WORKFLOW PERMISSIONS
#    - permissions: contents: write
#    - Required to create releases/tags
#    - Granted to GITHUB_TOKEN
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ HOW TO USE THIS WORKFLOW:
#
# SCENARIO 1: Release by merging to main
#   1. Update version in package.json (e.g., 1.0.0 â†’ 1.1.0)
#   2. Commit to development branch
#   3. Merge development â†’ main
#   4. This workflow automatically creates release!
#
# SCENARIO 2: Release by creating tag
#   1. git tag v1.1.0
#   2. git push origin v1.1.0
#   3. This workflow creates the release!
#
# WHAT YOU GET:
#   âœ… GitHub release with changelog
#   âœ… Downloadable package zip
#   âœ… Updated CHANGELOG.md file
#   âœ… Professional release notes
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¡ TIPS:
#
# - Use conventional commits (feat:, fix:, docs:) for better changelogs
# - Bump version in package.json before merging to main
# - Check existing releases before creating new version
# - Test on development branch before releasing
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

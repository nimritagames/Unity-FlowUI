# ═══════════════════════════════════════════════════════════════════════════
# 📚 LEARNING: Release Workflow
# ═══════════════════════════════════════════════════════════════════════════
#
# PURPOSE: This workflow automates releases when you merge to 'main' branch.
#          It creates GitHub releases, generates changelogs, and publishes
#          your package automatically!
#
# WHEN IT RUNS:
#   - When you push to main branch (e.g., merging development → main)
#   - When you create a version tag (e.g., v1.0.0, v1.1.0)
#
# WHAT IT DOES:
#   1. Detects version from package.json
#   2. Creates GitHub release with auto-generated changelog
#   3. Uploads package as release artifact
#   4. Tags the commit if not already tagged
#
# WHY THIS MATTERS:
#   - Automates the entire release process (saves hours!)
#   - Professional release notes from commit messages
#   - Users can install directly from releases
#   - Maintains version history automatically
#
# YOUR WORKFLOW:
#   development (daily work) → main (trigger this!) → GitHub Release
#
# ═══════════════════════════════════════════════════════════════════════════

name: Release Package

# 📚 LEARNING: This workflow has TWO triggers
on:
  # 📚 LEARNING: Trigger on pushes to main OR version tags
  push:
    # Trigger 1: When you push to main (e.g., merge development)
    branches:
      - main
    # Trigger 2: When you create a version tag manually (e.g., v1.1.0)
    tags:
      - 'v*'  # Matches v1.0.0, v2.1.3, etc.
    # 📚 LEARNING: Only run if package.json version changed
    # This prevents releases on every main push (only applies to branch pushes)
    paths:
      - 'Packages/com.nimrita.flowui/package.json'

# 📚 LEARNING: Environment variables for this workflow
env:
  PACKAGE_PATH: Packages/com.nimrita.flowui

# 📚 LEARNING: We need write permissions to create releases
permissions:
  contents: write  # Allows creating releases and tags

jobs:

  # ═══════════════════════════════════════════════════════════════════════════
  # JOB 1: Create GitHub Release
  # ═══════════════════════════════════════════════════════════════════════════

  create-release:
    name: 🚀 Create Release
    runs-on: ubuntu-latest

    # 📚 LEARNING: Only run if tests passed on development branch
    # This ensures we don't release broken code
    # Note: You can add a "needs: test" dependency once tests run on main too

    steps:

      # ─────────────────────────────────────────────────────────────────────
      # STEP 1: Get the code
      # ─────────────────────────────────────────────────────────────────────

      - name: 📥 Checkout Repository
        uses: actions/checkout@v4
        with:
          # 📚 LEARNING: Fetch all history for changelog generation
          fetch-depth: 0

      # ─────────────────────────────────────────────────────────────────────
      # STEP 2: Extract version from package.json
      # ─────────────────────────────────────────────────────────────────────

      # 📚 LEARNING: We read the version from package.json
      # This is the single source of truth for versioning
      - name: 📋 Get Package Version
        id: package-version
        run: |
          # Read version from package.json using jq (JSON processor)
          VERSION=$(jq -r '.version' ${{ env.PACKAGE_PATH }}/package.json)

          # 📚 LEARNING: Set output variable for use in later steps
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

          echo "📦 Package Version: $VERSION"
          echo "🏷️  Tag will be: v$VERSION"

      # ─────────────────────────────────────────────────────────────────────
      # STEP 3: Check if this version already exists
      # ─────────────────────────────────────────────────────────────────────

      # 📚 LEARNING: Prevent duplicate releases
      - name: 🔍 Check if Release Exists
        id: check-release
        run: |
          TAG="${{ steps.package-version.outputs.tag }}"

          # Check if tag exists remotely
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "⚠️  Release $TAG already exists!"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "✅ Release $TAG is new!"
          fi

      # ─────────────────────────────────────────────────────────────────────
      # STEP 4: Generate Changelog
      # ─────────────────────────────────────────────────────────────────────

      # 📚 LEARNING: Auto-generate changelog from commit messages
      # This step only runs if release doesn't exist
      - name: 📝 Generate Changelog
        id: changelog
        if: steps.check-release.outputs.exists == 'false'
        run: |
          TAG="${{ steps.package-version.outputs.tag }}"

          # 📚 LEARNING: Find the previous release tag
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # 📚 LEARNING: First release - get all commits
            echo "## 🎉 Initial Release" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "### Changes" >> CHANGELOG.md
            git log --pretty=format:"- %s" >> CHANGELOG.md
          else
            # 📚 LEARNING: Generate changelog since last release
            echo "## Changes since $PREV_TAG" > CHANGELOG.md
            echo "" >> CHANGELOG.md

            # Group commits by type (feat, fix, docs, etc.)
            echo "### ✨ Features" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --grep="^feat" >> CHANGELOG.md || echo "- No new features" >> CHANGELOG.md
            echo "" >> CHANGELOG.md

            echo "### 🐛 Bug Fixes" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --grep="^fix" >> CHANGELOG.md || echo "- No bug fixes" >> CHANGELOG.md
            echo "" >> CHANGELOG.md

            echo "### 📚 Documentation" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --grep="^docs" >> CHANGELOG.md || echo "- No documentation changes" >> CHANGELOG.md
            echo "" >> CHANGELOG.md

            echo "### 🔧 Other Changes" >> CHANGELOG.md
            git log $PREV_TAG..HEAD --pretty=format:"- %s" --invert-grep --grep="^feat" --grep="^fix" --grep="^docs" >> CHANGELOG.md || echo "- No other changes" >> CHANGELOG.md
          fi

          echo "" >> CHANGELOG.md
          echo "---" >> CHANGELOG.md
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREV_TAG...$TAG" >> CHANGELOG.md

          # 📚 LEARNING: Show the changelog
          echo "📄 Generated Changelog:"
          cat CHANGELOG.md

      # ─────────────────────────────────────────────────────────────────────
      # STEP 5: Create Package Archive
      # ─────────────────────────────────────────────────────────────────────

      # 📚 LEARNING: Create a .zip of the package for users to download
      - name: 📦 Create Package Archive
        if: steps.check-release.outputs.exists == 'false'
        run: |
          PACKAGE_NAME="com.nimrita.flowui-${{ steps.package-version.outputs.version }}"

          # Create a clean copy of the package
          mkdir -p dist
          cp -r ${{ env.PACKAGE_PATH }} "dist/$PACKAGE_NAME"

          # Create zip archive
          cd dist
          zip -r "../$PACKAGE_NAME.zip" "$PACKAGE_NAME"
          cd ..

          echo "✅ Created: $PACKAGE_NAME.zip"
          ls -lh "$PACKAGE_NAME.zip"

      # ─────────────────────────────────────────────────────────────────────
      # STEP 6: Create GitHub Release
      # ─────────────────────────────────────────────────────────────────────

      # 📚 LEARNING: This uses GitHub CLI (gh) to create the release
      - name: 🎉 Create GitHub Release
        if: steps.check-release.outputs.exists == 'false'
        env:
          # 📚 LEARNING: GitHub automatically provides this token
          # It has permissions based on the workflow's permissions setting
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.package-version.outputs.tag }}"
          VERSION="${{ steps.package-version.outputs.version }}"
          PACKAGE_NAME="com.nimrita.flowui-$VERSION"

          # 📚 LEARNING: Create the release with the generated changelog
          gh release create "$TAG" \
            --title "Flow UI System v$VERSION" \
            --notes-file CHANGELOG.md \
            "$PACKAGE_NAME.zip#Unity Package ($VERSION)"

          echo "✅ Created release: $TAG"
          echo "📦 Uploaded: $PACKAGE_NAME.zip"
          echo "🔗 View at: https://github.com/${{ github.repository }}/releases/tag/$TAG"

      # ─────────────────────────────────────────────────────────────────────
      # STEP 7: Update CHANGELOG.md in repository
      # ─────────────────────────────────────────────────────────────────────

      # 📚 LEARNING: Optional - Auto-update CHANGELOG.md file
      # This keeps your changelog file in sync with releases
      - name: 📝 Update Repository Changelog
        if: steps.check-release.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.package-version.outputs.version }}"
          DATE=$(date +%Y-%m-%d)

          # Prepend new changelog to existing CHANGELOG.md
          if [ -f "${{ env.PACKAGE_PATH }}/CHANGELOG.md" ]; then
            # Read existing changelog
            cp "${{ env.PACKAGE_PATH }}/CHANGELOG.md" CHANGELOG_OLD.md

            # Create new changelog with new version at top
            echo "# Changelog" > "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            echo "" >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            echo "## [$VERSION] - $DATE" >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            cat CHANGELOG.md >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"
            echo "" >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"

            # Append old changelog (skip the "# Changelog" header)
            tail -n +2 CHANGELOG_OLD.md >> "${{ env.PACKAGE_PATH }}/CHANGELOG.md"

            echo "✅ Updated CHANGELOG.md"
          fi

      # ─────────────────────────────────────────────────────────────────────
      # STEP 8: Commit Updated Changelog (Optional)
      # ─────────────────────────────────────────────────────────────────────

      # 📚 LEARNING: This commits the updated CHANGELOG.md back to the repo
      # Comment this out if you prefer manual changelog management
      - name: 💾 Commit Updated Changelog
        if: steps.check-release.outputs.exists == 'false'
        run: |
          # 📚 LEARNING: Configure git for the GitHub Actions bot
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes to commit
          if git diff --quiet ${{ env.PACKAGE_PATH }}/CHANGELOG.md; then
            echo "No changelog changes to commit"
          else
            git add ${{ env.PACKAGE_PATH }}/CHANGELOG.md
            git commit -m "docs: Update CHANGELOG for v${{ steps.package-version.outputs.version }}"
            git push origin main
            echo "✅ Committed updated CHANGELOG.md"
          fi

  # ═══════════════════════════════════════════════════════════════════════════
  # JOB 2: Notify on Success
  # ═══════════════════════════════════════════════════════════════════════════

  # 📚 LEARNING: This job runs after create-release completes
  notify:
    name: 📢 Notify Release
    runs-on: ubuntu-latest
    needs: create-release  # Wait for release to complete
    if: success()  # Only run if release succeeded

    steps:
      - name: 🎊 Release Success
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🎉 RELEASE SUCCESSFUL!"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "📦 Package: Flow UI System"
          echo "🏷️  Version: ${{ needs.create-release.outputs.version }}"
          echo "🔗 Release: https://github.com/${{ github.repository }}/releases"
          echo ""
          echo "✅ Users can now install this version!"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# ═══════════════════════════════════════════════════════════════════════════
# 📚 LEARNING SUMMARY
# ═══════════════════════════════════════════════════════════════════════════
#
# KEY CONCEPTS YOU JUST LEARNED:
#
# 1. RELEASE AUTOMATION
#    - Triggered by pushes to main or version tags
#    - Single source of truth: package.json version
#    - Prevents duplicate releases automatically
#
# 2. CHANGELOG GENERATION
#    - Auto-generated from commit messages
#    - Groups by commit type (feat, fix, docs)
#    - Compares with previous release tag
#
# 3. GITHUB RELEASES
#    - Created using GitHub CLI (gh)
#    - Includes generated changelog
#    - Attaches package zip for download
#
# 4. VERSION MANAGEMENT
#    - Reads from package.json
#    - Creates matching git tag (v1.0.0)
#    - Updates CHANGELOG.md automatically
#
# 5. JOB DEPENDENCIES
#    - needs: create-release (waits for completion)
#    - if: success() (conditional execution)
#    - Job outputs passed between jobs
#
# 6. GITHUB CLI (gh)
#    - gh release create (creates releases)
#    - Uses GITHUB_TOKEN (auto-provided)
#    - Can attach files to releases
#
# 7. WORKFLOW PERMISSIONS
#    - permissions: contents: write
#    - Required to create releases/tags
#    - Granted to GITHUB_TOKEN
#
# ═══════════════════════════════════════════════════════════════════════════
# 🎯 HOW TO USE THIS WORKFLOW:
#
# SCENARIO 1: Release by merging to main
#   1. Update version in package.json (e.g., 1.0.0 → 1.1.0)
#   2. Commit to development branch
#   3. Merge development → main
#   4. This workflow automatically creates release!
#
# SCENARIO 2: Release by creating tag
#   1. git tag v1.1.0
#   2. git push origin v1.1.0
#   3. This workflow creates the release!
#
# WHAT YOU GET:
#   ✅ GitHub release with changelog
#   ✅ Downloadable package zip
#   ✅ Updated CHANGELOG.md file
#   ✅ Professional release notes
#
# ═══════════════════════════════════════════════════════════════════════════
# 💡 TIPS:
#
# - Use conventional commits (feat:, fix:, docs:) for better changelogs
# - Bump version in package.json before merging to main
# - Check existing releases before creating new version
# - Test on development branch before releasing
#
# ═══════════════════════════════════════════════════════════════════════════
